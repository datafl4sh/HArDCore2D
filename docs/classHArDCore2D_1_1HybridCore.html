<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: HArDCore2D::HybridCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>HArDCore2D</b></li><li class="navelem"><a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHArDCore2D_1_1HybridCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HArDCore2D::HybridCore Class Reference<div class="ingroups"><a class="el" href="group__HybridCore.html">HybridCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">qrule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">description of one point and one weight from a quadrature rule  <a href="structHArDCore2D_1_1HybridCore_1_1qrule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="memItemLeft" align="right" valign="top"><a id="a4b9c53f6ec13dc9e73f5cdc5c8ae782b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">cell_basis_type</a> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="memdesc:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="memItemLeft" align="right" valign="top"><a id="a41350d7c3ac5a5a5e932348d2c9d0750"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">cell_gradient_type</a> = std::function&lt; Eigen::Vector2d(double, double)&gt;</td></tr>
<tr class="memdesc:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for gradients of cell basis <br /></td></tr>
<tr class="separator:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2030ea16722179fd3523e6e6675948"><td class="memItemLeft" align="right" valign="top"><a id="a1f2030ea16722179fd3523e6e6675948"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a1f2030ea16722179fd3523e6e6675948">edge_basis_type</a> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="memdesc:a1f2030ea16722179fd3523e6e6675948"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for edge basis <br /></td></tr>
<tr class="separator:a1f2030ea16722179fd3523e6e6675948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="memItemLeft" align="right" valign="top"><a id="ad9a6cc8ee2f9d26c936c5c61c358b538"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ad9a6cc8ee2f9d26c936c5c61c358b538">tensor_function_type</a> = std::function&lt; Eigen::Matrix2d(double, double)&gt;</td></tr>
<tr class="memdesc:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for 2D tensors basis <br /></td></tr>
<tr class="separator:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae189b44b4574688e4ae5c59d853317ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ae189b44b4574688e4ae5c59d853317ab">HybridCore</a> (const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *mesh_ptr, const size_t <a class="el" href="classHArDCore2D_1_1HybridCore.html#a74242d0a8b68fe5d9a35c6eb0effe3b2">K</a>, const size_t <a class="el" href="classHArDCore2D_1_1HybridCore.html#af5aea2e23e91c582d8c8189a5bc7ae96">L</a>)</td></tr>
<tr class="memdesc:ae189b44b4574688e4ae5c59d853317ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions.  <a href="#ae189b44b4574688e4ae5c59d853317ab">More...</a><br /></td></tr>
<tr class="separator:ae189b44b4574688e4ae5c59d853317ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bdc59d150566e1b992058031509d2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aa2bdc59d150566e1b992058031509d2f">dim_Pcell</a> (const size_t m) const</td></tr>
<tr class="memdesc:aa2bdc59d150566e1b992058031509d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 2-variate polynomials up to degree m.  <a href="#aa2bdc59d150566e1b992058031509d2f">More...</a><br /></td></tr>
<tr class="separator:aa2bdc59d150566e1b992058031509d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ab0fb57313f27fb8b4a6e9747de1d5cfe">dim_Pedge</a> (const size_t m) const</td></tr>
<tr class="memdesc:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 1-variate polynomials up to degree m.  <a href="#ab0fb57313f27fb8b4a6e9747de1d5cfe">More...</a><br /></td></tr>
<tr class="separator:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34242db07cc2b3c3b867d9e4580b634d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a34242db07cc2b3c3b867d9e4580b634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the cell iT.  <a href="#a34242db07cc2b3c3b867d9e4580b634d">More...</a><br /></td></tr>
<tr class="separator:a34242db07cc2b3c3b867d9e4580b634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a1f2030ea16722179fd3523e6e6675948">edge_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the edge iF.  <a href="#a6b4feaeef7739a2e30fcf6c601fcf721">More...</a><br /></td></tr>
<tr class="separator:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fc23b914623b90a2699ab4291e539"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a710fc23b914623b90a2699ab4291e539">cell_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a710fc23b914623b90a2699ab4291e539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th basis function of the celliT.  <a href="#a710fc23b914623b90a2699ab4291e539">More...</a><br /></td></tr>
<tr class="separator:a710fc23b914623b90a2699ab4291e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6b463bf137045e5581f9aab80e9a19"><td class="memItemLeft" align="right" valign="top"><a id="aee6b463bf137045e5581f9aab80e9a19"></a>
const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aee6b463bf137045e5581f9aab80e9a19">get_mesh_ptr</a> ()</td></tr>
<tr class="memdesc:aee6b463bf137045e5581f9aab80e9a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the mesh <br /></td></tr>
<tr class="separator:aee6b463bf137045e5581f9aab80e9a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd6ca61d4f9e3f3e3af81d8de394d0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9ecd6ca61d4f9e3f3e3af81d8de394d0">cell_qrule</a> (const size_t iT, const size_t doe) const</td></tr>
<tr class="memdesc:a9ecd6ca61d4f9e3f3e3af81d8de394d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quadrature rule of a given degree of exactness on a cell.  <a href="#a9ecd6ca61d4f9e3f3e3af81d8de394d0">More...</a><br /></td></tr>
<tr class="separator:a9ecd6ca61d4f9e3f3e3af81d8de394d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448297d0d0afefe477815dfb7821b270"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a448297d0d0afefe477815dfb7821b270">edge_qrule</a> (const size_t iE, const size_t doe) const</td></tr>
<tr class="memdesc:a448297d0d0afefe477815dfb7821b270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quadrature rule of a given degree of exactness on an edge.  <a href="#a448297d0d0afefe477815dfb7821b270">More...</a><br /></td></tr>
<tr class="separator:a448297d0d0afefe477815dfb7821b270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b46a742045262030431b73eb112f9c"><td class="memItemLeft" align="right" valign="top"><a id="a02b46a742045262030431b73eb112f9c"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">restr</a> (const Eigen::VectorXd &amp;Xh, size_t iT) const</td></tr>
<tr class="memdesc:a02b46a742045262030431b73eb112f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from a global vector Xh of unknowns the unknowns corresponding to cell iT. <br /></td></tr>
<tr class="separator:a02b46a742045262030431b73eb112f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memItemLeft" align="right" valign="top"><a id="a6c2a3d4fde899dde50fda5d97eafdc07"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a6c2a3d4fde899dde50fda5d97eafdc07">L2norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962007697ffc13367070f7c4bcbe875"><td class="memItemLeft" align="right" valign="top"><a id="a5962007697ffc13367070f7c4bcbe875"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a5962007697ffc13367070f7c4bcbe875">H1norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a5962007697ffc13367070f7c4bcbe875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete H1 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a5962007697ffc13367070f7c4bcbe875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8878fba08f008f5ecbaa69a9a084904"><td class="memItemLeft" align="right" valign="top"><a id="ac8878fba08f008f5ecbaa69a9a084904"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ac8878fba08f008f5ecbaa69a9a084904">Linf_edge</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:ac8878fba08f008f5ecbaa69a9a084904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum of the coefficients on the edge basis functions. <br /></td></tr>
<tr class="separator:ac8878fba08f008f5ecbaa69a9a084904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga71c953efc96f467cb24faa1b60ee9bb2">interpolate</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolant in the discrete space of a continuous function. <br /></td></tr>
<tr class="separator:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f34d7feff2d992c1004d1c67a660320"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a0f34d7feff2d992c1004d1c67a660320">gram_matrix</a> (const std::vector&lt; Eigen::VectorXd &gt; &amp;f_quad, const std::vector&lt; Eigen::VectorXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;quad, const bool &amp;sym, std::function&lt; double(double, double)&gt; weight=[&amp;](double x, double y){ return 1;}) const</td></tr>
<tr class="separator:a0f34d7feff2d992c1004d1c67a660320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633814c5b4f35034d04b74f09802303d"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a633814c5b4f35034d04b74f09802303d">gram_matrix</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;F_quad, const std::vector&lt; Eigen::MatrixXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;quad, const bool &amp;sym, std::function&lt; Eigen::Matrix2d(double, double)&gt; Weight=[&amp;](double x, double y){ return Eigen::Matrix2d::Identity();}) const</td></tr>
<tr class="memdesc:a633814c5b4f35034d04b74f09802303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded version of the previous one for vector-valued functions.  <a href="#a633814c5b4f35034d04b74f09802303d">More...</a><br /></td></tr>
<tr class="separator:a633814c5b4f35034d04b74f09802303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825c5d156026d465a2798389aa952b"><td class="memItemLeft" align="right" valign="top"><a id="a06825c5d156026d465a2798389aa952b"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a> (size_t iT) const</td></tr>
<tr class="memdesc:a06825c5d156026d465a2798389aa952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights to compute cell unknowns from edge unknowns when l=-1. <br /></td></tr>
<tr class="separator:a06825c5d156026d465a2798389aa952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7afe2ff1f5a56ebe48b407bdf08d6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#adc7afe2ff1f5a56ebe48b407bdf08d6e">basis_quad</a> (const char B, const size_t iTF, const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt; quad, const size_t nbasis) const</td></tr>
<tr class="memdesc:adc7afe2ff1f5a56ebe48b407bdf08d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (cell or edge) basis functions at the quadrature points.  <a href="#adc7afe2ff1f5a56ebe48b407bdf08d6e">More...</a><br /></td></tr>
<tr class="separator:adc7afe2ff1f5a56ebe48b407bdf08d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14adb4f4cfdd2dc7f9be9bfd085e7d87"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a14adb4f4cfdd2dc7f9be9bfd085e7d87">grad_basis_quad</a> (const size_t iT, const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt; quad, const size_t nbasis) const</td></tr>
<tr class="memdesc:a14adb4f4cfdd2dc7f9be9bfd085e7d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 'grad phi_i' at the quadrature points, where phi_i are the cell basis functions.  <a href="#a14adb4f4cfdd2dc7f9be9bfd085e7d87">More...</a><br /></td></tr>
<tr class="separator:a14adb4f4cfdd2dc7f9be9bfd085e7d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed85cdfc0bb96c65ce201528366e92f8"><td class="memItemLeft" align="right" valign="top"><a id="aed85cdfc0bb96c65ce201528366e92f8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aed85cdfc0bb96c65ce201528366e92f8">integral</a> (const Eigen::VectorXd &amp;XTF) const</td></tr>
<tr class="memdesc:aed85cdfc0bb96c65ce201528366e92f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integral of a discrete function using cell unknowns. <br /></td></tr>
<tr class="separator:aed85cdfc0bb96c65ce201528366e92f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="memItemLeft" align="right" valign="top"><a id="a58dd478934c1f5b65ae8b7df31e8ead4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a58dd478934c1f5b65ae8b7df31e8ead4">evaluate_in_cell</a> (const Eigen::VectorXd XTF, size_t iT, double x, double y) const</td></tr>
<tr class="memdesc:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function in the cell iT at point (x,y) <br /></td></tr>
<tr class="separator:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6795e8bc0058be7e399b379333032c8"><td class="memItemLeft" align="right" valign="top"><a id="ae6795e8bc0058be7e399b379333032c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ae6795e8bc0058be7e399b379333032c8">evaluate_in_edge</a> (const Eigen::VectorXd XTF, size_t iF, double x, double y) const</td></tr>
<tr class="memdesc:ae6795e8bc0058be7e399b379333032c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function on the edge iF at point (x,y) <br /></td></tr>
<tr class="separator:ae6795e8bc0058be7e399b379333032c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74242d0a8b68fe5d9a35c6eb0effe3b2"><td class="memItemLeft" align="right" valign="top"><a id="a74242d0a8b68fe5d9a35c6eb0effe3b2"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a74242d0a8b68fe5d9a35c6eb0effe3b2">K</a> ()</td></tr>
<tr class="memdesc:a74242d0a8b68fe5d9a35c6eb0effe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of edge unknowns <br /></td></tr>
<tr class="separator:a74242d0a8b68fe5d9a35c6eb0effe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aea2e23e91c582d8c8189a5bc7ae96"><td class="memItemLeft" align="right" valign="top"><a id="af5aea2e23e91c582d8c8189a5bc7ae96"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#af5aea2e23e91c582d8c8189a5bc7ae96">L</a> ()</td></tr>
<tr class="memdesc:af5aea2e23e91c582d8c8189a5bc7ae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of cell unknowns <br /></td></tr>
<tr class="separator:af5aea2e23e91c582d8c8189a5bc7ae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc772d1adc056fb4bf725f39c92edbb5"><td class="memItemLeft" align="right" valign="top"><a id="abc772d1adc056fb4bf725f39c92edbb5"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#abc772d1adc056fb4bf725f39c92edbb5">Ldeg</a> ()</td></tr>
<tr class="memdesc:abc772d1adc056fb4bf725f39c92edbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">usually equal to L, but put at 0 if L=-1 <br /></td></tr>
<tr class="separator:abc772d1adc056fb4bf725f39c92edbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728e5b5aa3675a64e7dbc593ed9761f8"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga728e5b5aa3675a64e7dbc593ed9761f8">ntotal_dofs</a> ()</td></tr>
<tr class="memdesc:ga728e5b5aa3675a64e7dbc593ed9761f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of degrees of freedom. <br /></td></tr>
<tr class="separator:ga728e5b5aa3675a64e7dbc593ed9761f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faceb46cc896cd6d82a821828518730"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga6faceb46cc896cd6d82a821828518730">nlocal_cell_dofs</a> ()</td></tr>
<tr class="memdesc:ga6faceb46cc896cd6d82a821828518730"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom in each cell (dimension of polynomial space) <br /></td></tr>
<tr class="separator:ga6faceb46cc896cd6d82a821828518730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97e3efcc37ac51074c7136af3ca517b"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaf97e3efcc37ac51074c7136af3ca517b">ntotal_cell_dofs</a> ()</td></tr>
<tr class="memdesc:gaf97e3efcc37ac51074c7136af3ca517b"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom <br /></td></tr>
<tr class="separator:gaf97e3efcc37ac51074c7136af3ca517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a45e5ff09d21b18874e1446cd9de9bc"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga6a45e5ff09d21b18874e1446cd9de9bc">nlocal_edge_dofs</a> ()</td></tr>
<tr class="memdesc:ga6a45e5ff09d21b18874e1446cd9de9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom on each cell (dimension of polynomial space) <br /></td></tr>
<tr class="separator:ga6a45e5ff09d21b18874e1446cd9de9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a703b6786215e5acf8bb59ecdbc9ea"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga49a703b6786215e5acf8bb59ecdbc9ea">ntotal_edge_dofs</a> ()</td></tr>
<tr class="memdesc:ga49a703b6786215e5acf8bb59ecdbc9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom <br /></td></tr>
<tr class="separator:ga49a703b6786215e5acf8bb59ecdbc9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e771ab58f248db8f051d47de982cf5"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gae6e771ab58f248db8f051d47de982cf5">ninternal_edge_dofs</a> ()</td></tr>
<tr class="memdesc:gae6e771ab58f248db8f051d47de982cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of edge degrees of freedom for internal edges <br /></td></tr>
<tr class="separator:gae6e771ab58f248db8f051d47de982cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd63afc45211d3005f6e25682c533b2"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga5fd63afc45211d3005f6e25682c533b2">nboundary_edge_dofs</a> ()</td></tr>
<tr class="memdesc:ga5fd63afc45211d3005f6e25682c533b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of edge degrees of freedom for boundary edges <br /></td></tr>
<tr class="separator:ga5fd63afc45211d3005f6e25682c533b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f78bc066429a18ad596d45a79d37bc"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaa7f78bc066429a18ad596d45a79d37bc">nhighorder_dofs</a> ()</td></tr>
<tr class="memdesc:gaa7f78bc066429a18ad596d45a79d37bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom with polynomials up to order k+1 <br /></td></tr>
<tr class="separator:gaa7f78bc066429a18ad596d45a79d37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c5ef5103bed8a3e0ecc18d592b1f9"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga6f7c5ef5103bed8a3e0ecc18d592b1f9">ngradient_dofs</a> ()</td></tr>
<tr class="memdesc:ga6f7c5ef5103bed8a3e0ecc18d592b1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of degrees of freedom for gradients <br /></td></tr>
<tr class="separator:ga6f7c5ef5103bed8a3e0ecc18d592b1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga3c33c8cec55dbe2d8873e53fcd43d01f">quadrature_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over a cell. <br /></td></tr>
<tr class="separator:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf9c61f2d929331197ba971b52b8710"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gafbf9c61f2d929331197ba971b52b8710"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gafbf9c61f2d929331197ba971b52b8710">quadrature_over_edge</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:gafbf9c61f2d929331197ba971b52b8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over an edge. <br /></td></tr>
<tr class="separator:gafbf9c61f2d929331197ba971b52b8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ffbc44306e06018efe3cea5a62f652"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga64ffbc44306e06018efe3cea5a62f652"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga64ffbc44306e06018efe3cea5a62f652">integrate_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga64ffbc44306e06018efe3cea5a62f652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over a cell. Use with parcimony, expensive (re-compute quadrature points) <br /></td></tr>
<tr class="separator:ga64ffbc44306e06018efe3cea5a62f652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f276ea9c905d64662c39b7555d560c"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga03f276ea9c905d64662c39b7555d560c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga03f276ea9c905d64662c39b7555d560c">integrate_over_edge</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga03f276ea9c905d64662c39b7555d560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over an edge. Use with parcimony, expensive (re-compute quadrature points) <br /></td></tr>
<tr class="separator:ga03f276ea9c905d64662c39b7555d560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058c4e54d1e33c49e537b8d0f602848"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gab058c4e54d1e33c49e537b8d0f602848"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gab058c4e54d1e33c49e537b8d0f602848">integrate_over_domain</a> (const Function &amp;f) const</td></tr>
<tr class="memdesc:gab058c4e54d1e33c49e537b8d0f602848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over the domaine. Use with parcimony, expensive (re-compute quadrature points) <br /></td></tr>
<tr class="separator:gab058c4e54d1e33c49e537b8d0f602848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> class provides convenient interfaces for performing integration over mesh cells and faces and handling polynomial basis functions The class also provides convenient interfaces for dealing with solutions to Hybrid High-Order schemes, such as the computation of integrals, norms and interpolants in the HHO space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae189b44b4574688e4ae5c59d853317ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae189b44b4574688e4ae5c59d853317ab">&#9670;&nbsp;</a></span>HybridCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A pointer to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the edge polynomials </td></tr>
    <tr><td class="paramname">L</td><td>The degree of the cell polynomials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc7afe2ff1f5a56ebe48b407bdf08d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7afe2ff1f5a56ebe48b407bdf08d6e">&#9670;&nbsp;</a></span>basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::VectorXd &gt; HybridCore::basis_quad </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iTF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nbasis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes (cell or edge) basis functions at the quadrature points. </p>
<dl class="section return"><dt>Returns</dt><dd>phi_quad[i] = vector listing values of phi_i at the quadrature nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>T for cell, E for edge </td></tr>
    <tr><td class="paramname">iTF</td><td>global index of the cell/edge </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature points and weights on the cell/edge </td></tr>
    <tr><td class="paramname">nbasis</td><td>number of basis functions to consider </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34242db07cc2b3c3b867d9e4580b634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34242db07cc2b3c3b867d9e4580b634d">&#9670;&nbsp;</a></span>cell_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">HybridCore::cell_basis_type</a> &amp; HybridCore::cell_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the cell iT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710fc23b914623b90a2699ab4291e539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710fc23b914623b90a2699ab4291e539">&#9670;&nbsp;</a></span>cell_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">HybridCore::cell_gradient_type</a> &amp; HybridCore::cell_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th basis function of the celliT. </p>
<p>Note that the gradient functions are indexed the same as the basis functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant basis function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ecd6ca61d4f9e3f3e3af81d8de394d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecd6ca61d4f9e3f3e3af81d8de394d0">&#9670;&nbsp;</a></span>cell_qrule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; HybridCore::cell_qrule </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>doe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a quadrature rule of a given degree of exactness on a cell. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature points and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>Global index of the cell </td></tr>
    <tr><td class="paramname">doe</td><td>Required degree of exactness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2bdc59d150566e1b992058031509d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bdc59d150566e1b992058031509d2f">&#9670;&nbsp;</a></span>dim_Pcell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pcell </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 2-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0fb57313f27fb8b4a6e9747de1d5cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fb57313f27fb8b4a6e9747de1d5cfe">&#9670;&nbsp;</a></span>dim_Pedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pedge </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 1-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b4feaeef7739a2e30fcf6c601fcf721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4feaeef7739a2e30fcf6c601fcf721">&#9670;&nbsp;</a></span>edge_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a1f2030ea16722179fd3523e6e6675948">HybridCore::edge_basis_type</a> &amp; HybridCore::edge_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the edge iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global edge number of the edge </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a448297d0d0afefe477815dfb7821b270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448297d0d0afefe477815dfb7821b270">&#9670;&nbsp;</a></span>edge_qrule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; HybridCore::edge_qrule </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>doe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a quadrature rule of a given degree of exactness on an edge. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature points and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iE</td><td>Global index of the edge </td></tr>
    <tr><td class="paramname">doe</td><td>Required degree of exactness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14adb4f4cfdd2dc7f9be9bfd085e7d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14adb4f4cfdd2dc7f9be9bfd085e7d87">&#9670;&nbsp;</a></span>grad_basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; HybridCore::grad_basis_quad </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nbasis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 'grad phi_i' at the quadrature points, where phi_i are the cell basis functions. </p>
<dl class="section return"><dt>Returns</dt><dd>dphi_quad[i]: 2*nb of quad points matrix, with each column being 'grad phi_i' at the corresponding quadrature point </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>global index of the cell </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature rules in the cell </td></tr>
    <tr><td class="paramname">nbasis</td><td>number of basis functions phi_i to consider </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f34d7feff2d992c1004d1c67a660320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f34d7feff2d992c1004d1c67a660320">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double, double)&gt;&#160;</td>
          <td class="paramname"><em>weight</em> = <code>[&amp;](double&#160;x,double&#160;y){&#160;return&#160;1;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the matrix of L2 products of two families (f_i) and (g_j) of functions (this is not really a Gram matrix, unless the two families are the same) </p><dl class="section return"><dt>Returns</dt><dd>The matrix of the integral of f_i * g_j </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Values of functions (f1,f2,...) at the quadrature points </td></tr>
    <tr><td class="paramname">g_quad</td><td>Values of functions (g1,g2,...) at the quadrature points </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions fi </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns of the matrix - typically number of functions gj </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature points for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #f&lt;=#g and f_i=g_i if i&lt;=#f) </td></tr>
    <tr><td class="paramname">weight</td><td>Optional weight for the L2 product </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a633814c5b4f35034d04b74f09802303d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633814c5b4f35034d04b74f09802303d">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structHArDCore2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix2d(double, double)&gt;&#160;</td>
          <td class="paramname"><em>Weight</em> = <code>[&amp;](double&#160;x,double&#160;y){&#160;return&#160;Eigen::Matrix2d::Identity();}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded version of the previous one for vector-valued functions. </p>
<p>F_i and G_j are vector-valued functions </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/HybridCore/<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a></li>
<li>src/HybridCore/hybridcore.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
