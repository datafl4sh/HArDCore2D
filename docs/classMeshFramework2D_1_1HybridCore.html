<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: MeshFramework2D::HybridCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MeshFramework2D</b></li><li class="navelem"><a class="el" href="classMeshFramework2D_1_1HybridCore.html">HybridCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMeshFramework2D_1_1HybridCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MeshFramework2D::HybridCore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classMeshFramework2D_1_1HybridCore.html" title="The HybridCore class provides convenient interfaces for performing integration over mesh cells and fa...">HybridCore</a> class provides convenient interfaces for performing integration over mesh cells and faces and handling polynomial basis functions.  
 <a href="classMeshFramework2D_1_1HybridCore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hybridcore-09March2019_8hpp_source.html">hybridcore-09March2019.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">qrule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad46944ac8070f647aa9e785f18aa8383"><td class="memItemLeft" align="right" valign="top"><a id="ad46944ac8070f647aa9e785f18aa8383"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cell_basis_type</b> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="separator:ad46944ac8070f647aa9e785f18aa8383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dd5c964443de7cbce7f2e975d8c3f"><td class="memItemLeft" align="right" valign="top"><a id="a539dd5c964443de7cbce7f2e975d8c3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cell_gradient_type</b> = std::function&lt; Eigen::Vector2d(double, double)&gt;</td></tr>
<tr class="separator:a539dd5c964443de7cbce7f2e975d8c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadffa71a4d7f8b48bf9f04fd2211ef7"><td class="memItemLeft" align="right" valign="top"><a id="abadffa71a4d7f8b48bf9f04fd2211ef7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_basis_type</b> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="separator:abadffa71a4d7f8b48bf9f04fd2211ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92853eab5ef4260077235e21f477e958"><td class="memItemLeft" align="right" valign="top"><a id="a92853eab5ef4260077235e21f477e958"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_function_type</b> = std::function&lt; Eigen::Matrix2d(double, double)&gt;</td></tr>
<tr class="separator:a92853eab5ef4260077235e21f477e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46944ac8070f647aa9e785f18aa8383"><td class="memItemLeft" align="right" valign="top"><a id="ad46944ac8070f647aa9e785f18aa8383"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cell_basis_type</b> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="separator:ad46944ac8070f647aa9e785f18aa8383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dd5c964443de7cbce7f2e975d8c3f"><td class="memItemLeft" align="right" valign="top"><a id="a539dd5c964443de7cbce7f2e975d8c3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cell_gradient_type</b> = std::function&lt; Eigen::Vector2d(double, double)&gt;</td></tr>
<tr class="separator:a539dd5c964443de7cbce7f2e975d8c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4fc16145e01888229f1ce27e31ccea9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#ab4fc16145e01888229f1ce27e31ccea9">HybridCore</a> (const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> *mesh_ptr, const size_t K, const size_t L)</td></tr>
<tr class="separator:ab4fc16145e01888229f1ce27e31ccea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aabd37f36e11bbcfffbb5bb59e54d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a09aabd37f36e11bbcfffbb5bb59e54d2">basis_size2d</a> (const size_t m) const</td></tr>
<tr class="memdesc:a09aabd37f36e11bbcfffbb5bb59e54d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 2-variate polynomials up to degree m.  <a href="#a09aabd37f36e11bbcfffbb5bb59e54d2">More...</a><br /></td></tr>
<tr class="separator:a09aabd37f36e11bbcfffbb5bb59e54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aad1cf56ccfe043d98d3e665f68de3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a08aad1cf56ccfe043d98d3e665f68de3">basis_size1d</a> (const size_t m) const</td></tr>
<tr class="memdesc:a08aad1cf56ccfe043d98d3e665f68de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 1-variate polynomials up to degree m.  <a href="#a08aad1cf56ccfe043d98d3e665f68de3">More...</a><br /></td></tr>
<tr class="separator:a08aad1cf56ccfe043d98d3e665f68de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34242db07cc2b3c3b867d9e4580b634d"><td class="memItemLeft" align="right" valign="top">const cell_basis_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a34242db07cc2b3c3b867d9e4580b634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the cell / region iR.  <a href="#a34242db07cc2b3c3b867d9e4580b634d">More...</a><br /></td></tr>
<tr class="separator:a34242db07cc2b3c3b867d9e4580b634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6facc0f763dc9662918a072c2b2cf2d"><td class="memItemLeft" align="right" valign="top">const edge_basis_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#ad6facc0f763dc9662918a072c2b2cf2d">edge_basis</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:ad6facc0f763dc9662918a072c2b2cf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the edge iF.  <a href="#ad6facc0f763dc9662918a072c2b2cf2d">More...</a><br /></td></tr>
<tr class="separator:ad6facc0f763dc9662918a072c2b2cf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fc23b914623b90a2699ab4291e539"><td class="memItemLeft" align="right" valign="top">const cell_gradient_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a710fc23b914623b90a2699ab4291e539">cell_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="separator:a710fc23b914623b90a2699ab4291e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1de3032113f03478e4a0b4aef0591b"><td class="memItemLeft" align="right" valign="top"><a id="adf1de3032113f03478e4a0b4aef0591b"></a>
const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_mesh_ptr</b> ()</td></tr>
<tr class="separator:adf1de3032113f03478e4a0b4aef0591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd6ca61d4f9e3f3e3af81d8de394d0"><td class="memItemLeft" align="right" valign="top"><a id="a9ecd6ca61d4f9e3f3e3af81d8de394d0"></a>
std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cell_qrule</b> (const size_t iT, const size_t doe) const</td></tr>
<tr class="separator:a9ecd6ca61d4f9e3f3e3af81d8de394d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960fd81b6dd36ec913a71fd6531cb0db"><td class="memItemLeft" align="right" valign="top"><a id="a960fd81b6dd36ec913a71fd6531cb0db"></a>
std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge_qrule</b> (const size_t iF, const size_t doe) const</td></tr>
<tr class="separator:a960fd81b6dd36ec913a71fd6531cb0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959f5d5a9fd98c719b0ef4595bbbca5"><td class="memTemplParams" colspan="2"><a id="a3959f5d5a9fd98c719b0ef4595bbbca5"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a3959f5d5a9fd98c719b0ef4595bbbca5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadrature_over_cell</b> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="separator:a3959f5d5a9fd98c719b0ef4595bbbca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8301bed2cb288663bdf0eaea6add5def"><td class="memItemLeft" align="right" valign="top"><a id="a8301bed2cb288663bdf0eaea6add5def"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>L2norm</b> (const Eigen::VectorXd &amp;XTF) const</td></tr>
<tr class="separator:a8301bed2cb288663bdf0eaea6add5def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad10216bd7a96947c648e9c92c8e11b"><td class="memItemLeft" align="right" valign="top"><a id="a4ad10216bd7a96947c648e9c92c8e11b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Linf_edge</b> (const Eigen::VectorXd &amp;XTF) const</td></tr>
<tr class="separator:a4ad10216bd7a96947c648e9c92c8e11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d23f6ca5a8fc8139f4b6670eabf6f49"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a7d23f6ca5a8fc8139f4b6670eabf6f49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a7d23f6ca5a8fc8139f4b6670eabf6f49">quadrature_over_edge</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="separator:a7d23f6ca5a8fc8139f4b6670eabf6f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed22ee426da685cf42663278e6d0b2a3"><td class="memTemplParams" colspan="2"><a id="aed22ee426da685cf42663278e6d0b2a3"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:aed22ee426da685cf42663278e6d0b2a3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_over_cell</b> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="separator:aed22ee426da685cf42663278e6d0b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memTemplParams" colspan="2"><a id="af2dcd1b81c27dff31f054ab1d4fcad2c"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_over_edge</b> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="separator:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc83b1c32e0950b80242850f6f75b682"><td class="memTemplParams" colspan="2"><a id="abc83b1c32e0950b80242850f6f75b682"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:abc83b1c32e0950b80242850f6f75b682"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_over_domain</b> (const Function &amp;f) const</td></tr>
<tr class="separator:abc83b1c32e0950b80242850f6f75b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119bb20655eb4f9f50faef9571ac0529"><td class="memTemplParams" colspan="2"><a id="a119bb20655eb4f9f50faef9571ac0529"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a119bb20655eb4f9f50faef9571ac0529"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate</b> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="separator:a119bb20655eb4f9f50faef9571ac0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed7f0bd7875c92ce8f258f1c45eaa3"><td class="memItemLeft" align="right" valign="top"><a id="affed7f0bd7875c92ce8f258f1c45eaa3"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>gram_matrix</b> (const std::vector&lt; Eigen::VectorXd &gt; &amp;f_quad, const std::vector&lt; Eigen::VectorXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;quad, const bool &amp;sym) const</td></tr>
<tr class="separator:affed7f0bd7875c92ce8f258f1c45eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c77d7e341d67b34662419db244705b"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a65c77d7e341d67b34662419db244705b">gram_matrix</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;F_quad, const std::vector&lt; Eigen::MatrixXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;quad, const bool &amp;sym) const</td></tr>
<tr class="separator:a65c77d7e341d67b34662419db244705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f5182b06c17e92cbd635379b553ae"><td class="memItemLeft" align="right" valign="top"><a id="ae77f5182b06c17e92cbd635379b553ae"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>compute_weights</b> (size_t iT) const</td></tr>
<tr class="separator:ae77f5182b06c17e92cbd635379b553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30be33160bb6dec597e54236607f4f3b"><td class="memItemLeft" align="right" valign="top"><a id="a30be33160bb6dec597e54236607f4f3b"></a>
std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>diff_grad_quad</b> (const size_t iT, const std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt; quad, tensor_function_type diff, const size_t nbasis) const</td></tr>
<tr class="separator:a30be33160bb6dec597e54236607f4f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ecaec3f38864d84587f02c9683f248"><td class="memItemLeft" align="right" valign="top"><a id="a70ecaec3f38864d84587f02c9683f248"></a>
std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>basis_quad</b> (const char B, const size_t iTF, const std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">qrule</a> &gt; quad, const size_t nbasis) const</td></tr>
<tr class="separator:a70ecaec3f38864d84587f02c9683f248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad3b9df433fbf84e4188e2ecffa4291"><td class="memItemLeft" align="right" valign="top"><a id="a3ad3b9df433fbf84e4188e2ecffa4291"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>integral</b> (const Eigen::VectorXd &amp;XTF) const</td></tr>
<tr class="separator:a3ad3b9df433fbf84e4188e2ecffa4291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb83cd5d8b68b40d1d4c40cc96f1750b"><td class="memItemLeft" align="right" valign="top"><a id="abb83cd5d8b68b40d1d4c40cc96f1750b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>evaluate_in_cell</b> (const Eigen::VectorXd XTF, size_t iT, double x, double y) const</td></tr>
<tr class="separator:abb83cd5d8b68b40d1d4c40cc96f1750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58908d01c15d3ee8e45c71d1b12f22fe"><td class="memItemLeft" align="right" valign="top"><a id="a58908d01c15d3ee8e45c71d1b12f22fe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>evaluate_in_edge</b> (const Eigen::VectorXd XTF, size_t iF, double x, double y) const</td></tr>
<tr class="separator:a58908d01c15d3ee8e45c71d1b12f22fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff52b273cb899d37f099ac95c4ebdcfb"><td class="memItemLeft" align="right" valign="top"><a id="aff52b273cb899d37f099ac95c4ebdcfb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nlocal_cell_dofs</b> ()</td></tr>
<tr class="separator:aff52b273cb899d37f099ac95c4ebdcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c43389b8464bbca85d1f42e02270306"><td class="memItemLeft" align="right" valign="top"><a id="a4c43389b8464bbca85d1f42e02270306"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ntotal_cell_dofs</b> ()</td></tr>
<tr class="separator:a4c43389b8464bbca85d1f42e02270306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac5e2d17f0ba51d14ce68c3ba88782c"><td class="memItemLeft" align="right" valign="top"><a id="a6ac5e2d17f0ba51d14ce68c3ba88782c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ntotal_dofs</b> ()</td></tr>
<tr class="separator:a6ac5e2d17f0ba51d14ce68c3ba88782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f8264739015f45de15d7857271f6d1"><td class="memItemLeft" align="right" valign="top"><a id="ad4f8264739015f45de15d7857271f6d1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nlocal_edge_dofs</b> ()</td></tr>
<tr class="separator:ad4f8264739015f45de15d7857271f6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd33967c9ff866d55a62455889f7beb"><td class="memItemLeft" align="right" valign="top"><a id="abbd33967c9ff866d55a62455889f7beb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ntotal_edge_dofs</b> ()</td></tr>
<tr class="separator:abbd33967c9ff866d55a62455889f7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af381ad55b32c332f2013d99f92f2b000"><td class="memItemLeft" align="right" valign="top"><a id="af381ad55b32c332f2013d99f92f2b000"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ninternal_edge_dofs</b> ()</td></tr>
<tr class="separator:af381ad55b32c332f2013d99f92f2b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4eff94635021ab179080a290d1463"><td class="memItemLeft" align="right" valign="top"><a id="a8de4eff94635021ab179080a290d1463"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nboundary_edge_dofs</b> ()</td></tr>
<tr class="separator:a8de4eff94635021ab179080a290d1463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a545403074f28fa17f2c688f0a6665"><td class="memItemLeft" align="right" valign="top"><a id="af2a545403074f28fa17f2c688f0a6665"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nhighorder_dofs</b> ()</td></tr>
<tr class="separator:af2a545403074f28fa17f2c688f0a6665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aefff14bebce4ebfe24da4b2f6e71a2"><td class="memItemLeft" align="right" valign="top"><a id="a0aefff14bebce4ebfe24da4b2f6e71a2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ngradient_dofs</b> ()</td></tr>
<tr class="separator:a0aefff14bebce4ebfe24da4b2f6e71a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe4668cae756f26a58eaea078ce18d"><td class="memItemLeft" align="right" valign="top"><a id="ac5fe4668cae756f26a58eaea078ce18d"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>K</b> ()</td></tr>
<tr class="separator:ac5fe4668cae756f26a58eaea078ce18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ae2cf70051bca8a8bf7f4af784097"><td class="memItemLeft" align="right" valign="top"><a id="af05ae2cf70051bca8a8bf7f4af784097"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>L</b> ()</td></tr>
<tr class="separator:af05ae2cf70051bca8a8bf7f4af784097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48608b10abcde52a9b7a6a456ada76ab"><td class="memItemLeft" align="right" valign="top"><a id="a48608b10abcde52a9b7a6a456ada76ab"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>Ldeg</b> ()</td></tr>
<tr class="separator:a48608b10abcde52a9b7a6a456ada76ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be8b1438197223b63153ce4331fb656"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a1be8b1438197223b63153ce4331fb656">HybridCore</a> (const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> *mesh_ptr, const size_t K)</td></tr>
<tr class="separator:a1be8b1438197223b63153ce4331fb656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6e62f18213ca052e181f09ae63556"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a8ae6e62f18213ca052e181f09ae63556">basis_size3d</a> (const size_t m) const</td></tr>
<tr class="memdesc:a8ae6e62f18213ca052e181f09ae63556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 3-variate polynomials up to degree m.  <a href="#a8ae6e62f18213ca052e181f09ae63556">More...</a><br /></td></tr>
<tr class="separator:a8ae6e62f18213ca052e181f09ae63556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f2cd27f9ab6269de1b7c4768b21ed0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#af6f2cd27f9ab6269de1b7c4768b21ed0">basis_size2d</a> (const size_t m) const</td></tr>
<tr class="memdesc:af6f2cd27f9ab6269de1b7c4768b21ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 2-variate polynomials up to degree m.  <a href="#af6f2cd27f9ab6269de1b7c4768b21ed0">More...</a><br /></td></tr>
<tr class="separator:af6f2cd27f9ab6269de1b7c4768b21ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205f1e764a58480cca800b5b301f89e"><td class="memItemLeft" align="right" valign="top">const cell_basis_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a0205f1e764a58480cca800b5b301f89e">cell_basis</a> (size_t iG, size_t i) const</td></tr>
<tr class="memdesc:a0205f1e764a58480cca800b5b301f89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the cell / region iR.  <a href="#a0205f1e764a58480cca800b5b301f89e">More...</a><br /></td></tr>
<tr class="separator:a0205f1e764a58480cca800b5b301f89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2292a9a5f8fe58d9a05c104419bcc2e"><td class="memItemLeft" align="right" valign="top">const cell_gradient_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#ae2292a9a5f8fe58d9a05c104419bcc2e">cell_gradient</a> (size_t iG, size_t i) const</td></tr>
<tr class="separator:ae2292a9a5f8fe58d9a05c104419bcc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac485aac154c0e9dbae4ac769415caff5"><td class="memItemLeft" align="right" valign="top"><a id="ac485aac154c0e9dbae4ac769415caff5"></a>
const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>mesh</b> () const</td></tr>
<tr class="separator:ac485aac154c0e9dbae4ac769415caff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b1336ddafe9acd0d6fa31867e0498"><td class="memItemLeft" align="right" valign="top"><a id="aab2b1336ddafe9acd0d6fa31867e0498"></a>
std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cell_qrule</b> (const size_t iF, const size_t doe) const</td></tr>
<tr class="separator:aab2b1336ddafe9acd0d6fa31867e0498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763180d9c9d0bc2afaf5119ebd5fe236"><td class="memItemLeft" align="right" valign="top"><a id="a763180d9c9d0bc2afaf5119ebd5fe236"></a>
std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge_qrule</b> (const size_t iE, const size_t doe) const</td></tr>
<tr class="separator:a763180d9c9d0bc2afaf5119ebd5fe236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf3142a23b473536a758bc85aa3a8e"><td class="memTemplParams" colspan="2"><a id="a70cf3142a23b473536a758bc85aa3a8e"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a70cf3142a23b473536a758bc85aa3a8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadrature_over_cell</b> (const size_t iC, const Function &amp;f) const</td></tr>
<tr class="separator:a70cf3142a23b473536a758bc85aa3a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4354cc25879093b3a1dcd0efe7e2e07a"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a4354cc25879093b3a1dcd0efe7e2e07a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a4354cc25879093b3a1dcd0efe7e2e07a">quadrature_over_edge</a> (const size_t iE, const Function &amp;f) const</td></tr>
<tr class="separator:a4354cc25879093b3a1dcd0efe7e2e07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4f67367d7b3fd016369aebd006b8aa"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a7b4f67367d7b3fd016369aebd006b8aa"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMeshFramework2D_1_1HybridCore.html#a7b4f67367d7b3fd016369aebd006b8aa">integrate_over_cell</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="separator:a7b4f67367d7b3fd016369aebd006b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memTemplParams" colspan="2"><a id="af2dcd1b81c27dff31f054ab1d4fcad2c"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_over_edge</b> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="separator:af2dcd1b81c27dff31f054ab1d4fcad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff52b273cb899d37f099ac95c4ebdcfb"><td class="memItemLeft" align="right" valign="top"><a id="aff52b273cb899d37f099ac95c4ebdcfb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nlocal_cell_dofs</b> ()</td></tr>
<tr class="separator:aff52b273cb899d37f099ac95c4ebdcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c43389b8464bbca85d1f42e02270306"><td class="memItemLeft" align="right" valign="top"><a id="a4c43389b8464bbca85d1f42e02270306"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ntotal_cell_dofs</b> ()</td></tr>
<tr class="separator:a4c43389b8464bbca85d1f42e02270306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac5e2d17f0ba51d14ce68c3ba88782c"><td class="memItemLeft" align="right" valign="top"><a id="a6ac5e2d17f0ba51d14ce68c3ba88782c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ntotal_dofs</b> ()</td></tr>
<tr class="separator:a6ac5e2d17f0ba51d14ce68c3ba88782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classMeshFramework2D_1_1HybridCore.html" title="The HybridCore class provides convenient interfaces for performing integration over mesh cells and fa...">HybridCore</a> class provides convenient interfaces for performing integration over mesh cells and faces and handling polynomial basis functions. </p>
<p>The class also provides convenient interfaces for dealing with solutions to Hybrid High-Order schemes, such as the computation of integrals, norms and interpolants in the HHO space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4fc16145e01888229f1ce27e31ccea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fc16145e01888229f1ce27e31ccea9">&#9670;&nbsp;</a></span>HybridCore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshFramework2D::HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the data structure with the given mesh, and desired polynomial degrees of the basis functions The mesh is stored in a <code>std::shared_ptr&lt;mesh_3Dv&gt;</code> to allow multiple schemes to share the same mesh data. The degree of exactness multipliers specify the accuracy of the quadrature rules required. Cell integrals will have a degree of exactness <img class="formulaInl" alt="$(K+1)\times k\_doe$" src="form_0.png"/> (to integrate high-order reconstructions), and face integrals will have degree of exactness <img class="formulaInl" alt="$K\times l\_doe + 1$" src="form_1.png"/>. The default values are 2, which are sufficient for Laplace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A std::shared_ptr to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the edge polynomials </td></tr>
    <tr><td class="paramname">L</td><td>The degree of the cell polynomials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1be8b1438197223b63153ce4331fb656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be8b1438197223b63153ce4331fb656">&#9670;&nbsp;</a></span>HybridCore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshFramework2D_1_1Mesh2D.html">Mesh2D</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the data structure with the given mesh, and desired polynomial degrees of the basis functions The mesh is stored in a <code>std::shared_ptr&lt;mesh_3Dv&gt;</code> to allow multiple schemes to share the same mesh data. The degree of exactness multipliers specify the accuracy of the quadrature rules required. Cell integrals will have a degree of exactness <img class="formulaInl" alt="$(K+1)\times k\_doe$" src="form_0.png"/> (to integrate high-order reconstructions), and face integrals will have degree of exactness <img class="formulaInl" alt="$K\times l\_doe + 1$" src="form_1.png"/>. The default values are 2, which are sufficient for Laplace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A std::shared_ptr to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the cell polynomials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08aad1cf56ccfe043d98d3e665f68de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aad1cf56ccfe043d98d3e665f68de3">&#9670;&nbsp;</a></span>basis_size1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MeshFramework2D::HybridCore::basis_size1d </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 1-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09aabd37f36e11bbcfffbb5bb59e54d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aabd37f36e11bbcfffbb5bb59e54d2">&#9670;&nbsp;</a></span>basis_size2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::basis_size2d </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 2-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f2cd27f9ab6269de1b7c4768b21ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f2cd27f9ab6269de1b7c4768b21ed0">&#9670;&nbsp;</a></span>basis_size2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MeshFramework2D::HybridCore::basis_size2d </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 2-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ae6e62f18213ca052e181f09ae63556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae6e62f18213ca052e181f09ae63556">&#9670;&nbsp;</a></span>basis_size3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::basis_size3d </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 3-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial * </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34242db07cc2b3c3b867d9e4580b634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34242db07cc2b3c3b867d9e4580b634d">&#9670;&nbsp;</a></span>cell_basis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const HybridCore::cell_basis_type &amp; HybridCore::cell_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the cell / region iR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0205f1e764a58480cca800b5b301f89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0205f1e764a58480cca800b5b301f89e">&#9670;&nbsp;</a></span>cell_basis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cell_basis_type&amp; MeshFramework2D::HybridCore::cell_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the cell / region iR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iG</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2292a9a5f8fe58d9a05c104419bcc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2292a9a5f8fe58d9a05c104419bcc2e">&#9670;&nbsp;</a></span>cell_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cell_gradient_type&amp; MeshFramework2D::HybridCore::cell_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the gradient of the i'th basis function of the cell / region iR Note that the gradient functions are indexed the same as the basis functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant basis function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iG</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710fc23b914623b90a2699ab4291e539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710fc23b914623b90a2699ab4291e539">&#9670;&nbsp;</a></span>cell_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const HybridCore::cell_gradient_type &amp; HybridCore::cell_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the gradient of the i'th basis function of the cell / region iR Note that the gradient functions are indexed the same as the basis functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant basis function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the region </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6facc0f763dc9662918a072c2b2cf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6facc0f763dc9662918a072c2b2cf2d">&#9670;&nbsp;</a></span>edge_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const edge_basis_type&amp; MeshFramework2D::HybridCore::edge_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the edge iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global edge number of the edge </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65c77d7e341d67b34662419db244705b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c77d7e341d67b34662419db244705b">&#9670;&nbsp;</a></span>gram_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd MeshFramework2D::HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structMeshFramework2D_1_1HybridCore_1_1qrule.html">HybridCore::qrule</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F_quad</td><td>F_quad[i].col(iqn) contains the value of F_i at the quadrature point of index iqn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4f67367d7b3fd016369aebd006b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4f67367d7b3fd016369aebd006b8aa">&#9670;&nbsp;</a></span>integrate_over_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double MeshFramework2D::HybridCore::integrate_over_cell </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td></td></tr>
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4354cc25879093b3a1dcd0efe7e2e07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4354cc25879093b3a1dcd0efe7e2e07a">&#9670;&nbsp;</a></span>quadrature_over_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshFramework2D::HybridCore::quadrature_over_edge </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iE</td><td></td></tr>
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d23f6ca5a8fc8139f4b6670eabf6f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d23f6ca5a8fc8139f4b6670eabf6f49">&#9670;&nbsp;</a></span>quadrature_over_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void HybridCore::quadrature_over_edge </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td></td></tr>
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>old/<a class="el" href="hybridcore-09March2019_8hpp_source.html">hybridcore-09March2019.hpp</a></li>
<li>old/Mesh2d/src/include/<a class="el" href="hybridcore2d_8h_source.html">hybridcore2d.h</a></li>
<li>old/Mesh2d/src/hybridcore2d.cpp</li>
<li>old/Mesh2d/src/include/<a class="el" href="old_2Mesh2d_2src_2include_2hybridcore2d_8hpp_source.html">hybridcore2d.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
